<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Monster Beat & Melody Monsters üéµ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        :root {
            --primary: #FF9FF3;
            --secondary: #54A0FF;
            --accent: #FECA57;
            --guitar-accent: #ff6b6b;
            --bg-dark: #1a1a2e;
            --text-dark: #2c3e50;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Fredoka One', cursive;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            color: white;
        }

        #app-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(to bottom, #16213e, #0f3460);
        }

        canvas {
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background: transparent;
            border-radius: 10px;
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            text-align: left;
            pointer-events: none;
        }

        .score-label {
            color: var(--accent);
            font-size: 1.2rem;
            text-shadow: 1px 1px 0px rgba(0,0,0,0.8);
        }

        .score-value {
            color: white;
            font-size: 2.5rem;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.8);
            margin: 0;
            line-height: 1;
        }

        .mode-hud {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.2rem;
            color: var(--secondary);
            text-shadow: 1px 1px 0px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        /* Screens */
        .modal {
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(5px);
            padding: 2rem;
            border-radius: 20px;
            border: 4px solid var(--primary);
            box-shadow: 0 0 30px var(--primary);
            pointer-events: auto;
            transition: opacity 0.3s ease;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        h1 {
            color: var(--primary);
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            text-shadow: 2px 2px 0px rgba(255,255,255,0.4);
            letter-spacing: 1px;
        }

        h2 {
            color: var(--secondary);
            font-size: 2rem;
            margin: 5px 0 10px 0;
        }

        p {
            font-size: 1rem;
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .small {
            font-size: 0.9rem;
            color: #ccc;
        }

        button {
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            border: none;
            padding: 12px 32px;
            font-size: 1.2rem;
            color: white;
            font-family: 'Fredoka One', cursive;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 0 #2a2a72;
            margin: 5px;
            transition: transform 0.1s, box-shadow 0.1s, filter 0.2s;
            display: inline-block;
        }

        button:active {
            transform: translateY(5px);
            box-shadow: 0 0 0 #2a2a72;
        }

        button:hover {
            filter: brightness(1.15);
        }

        button:disabled {
            background: #555;
            box-shadow: 0 5px 0 #333;
            cursor: not-allowed;
            opacity: 0.7;
        }

        button.secondary {
            background: linear-gradient(45deg, #4b7bec, #3867d6);
        }

        button.guitar-btn {
            background: linear-gradient(45deg, #eb3b5a, #fc5c65);
            box-shadow: 0 5px 0 #c44569;
        }
        
        button.guitar-btn:active {
            box-shadow: 0 0 0 #c44569;
        }

        .instrument-toggle {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        /* Melody Styles */
        .melody-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-bottom: 20px;
            max-width: 380px;
        }

        .melody-grid.learn-mode {
            gap: 15px;
            margin-bottom: 25px;
        }

        .melody-card {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 15px;
            padding: 10px 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s, border-color 0.2s;
        }

        .melody-card:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }

        .melody-card.active-sequence {
            background: var(--accent);
            border-color: #fff;
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--accent);
        }

        .melody-card .emoji {
            font-size: 2.5rem;
            margin-bottom: 5px;
        }
        
        .learn-mode .melody-card .emoji {
            font-size: 3rem; /* Bigger in learn mode */
        }

        .melody-card .note-name {
            font-size: 1.2rem;
            margin-top: 4px;
            color: #fff;
        }
        
        .learn-mode .melody-card .note-name {
            font-size: 1.4rem;
            font-weight: bold;
        }

        #instructions {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #ddd;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 10px;
        }

        .key {
            display: inline-block;
            background: #eee;
            color: #333;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            box-shadow: 0 2px 0 #ccc;
        }
    </style>
</head>
<body>

<div id="app-container">
    <canvas id="gameCanvas"></canvas>

    <!-- HUD (Score) -->
    <div id="hud" class="ui-layer hidden">
        <div class="hud">
            <div class="score-label">SCORE</div>
            <div id="scoreDisplay" class="score-value">0</div>
        </div>
        <div class="mode-hud" id="modeHud"></div>
    </div>

    <!-- Main Menu -->
    <div id="menu-screen" class="ui-layer">
        <div class="modal">
            <h1>Monster Beat & Melody Monsters üéµ</h1>
            <p>
                A gentle, musical game for kids who love monsters and melodies.<br>
                <span class="small">Soft sounds ‚Ä¢ Two play modes ‚Ä¢ No downloads</span>
            </p>
            <button id="playBeatBtn">‚ñ∂ Monster Beat</button>
            <button id="playMelodyBtn" class="secondary">üéµ Melody Monsters</button>
            <div id="instructions">
                <strong>Monster Beat:</strong> Press <span class="key">SPACE</span> or <span class="key">TAP</span> to jump.<br>
                Land on platforms to make notes. The higher the platform, the higher the note.<br><br>
                <strong>Melody Monsters:</strong> Learn your notes by ear! Choose Piano or Guitar style.
            </div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="ui-layer hidden">
        <div class="modal">
            <h1>GAME OVER</h1>
            <p id="finalScoreText">Score: 0</p>
            <p id="highScoreText">Best: 0</p>
            <p id="highNoteText" class="small">Highest Note Reached: ‚Äî</p>
            <button id="restartBtn">TRY AGAIN</button>
            <button id="backToMenuBtn" class="secondary">BACK TO MENU</button>
        </div>
    </div>

    <!-- Pause Screen -->
    <div id="pause-screen" class="ui-layer hidden">
        <div class="modal">
            <h1>PAUSED</h1>
            <button id="resumeBtn">‚ñ∂ RESUME</button>
            <button id="quitBtn" class="secondary">QUIT TO MENU</button>
        </div>
    </div>

    <!-- Melody Mode Intro -->
    <div id="melody-mode-screen" class="ui-layer hidden">
        <div class="modal">
            <h1>Melody Monsters üê±üéµ</h1>
            <p>Choose an instrument to hear different musical scales!</p>
            
            <div class="instrument-toggle">
                <button id="setPianoBtn" class="active">üéπ Piano</button>
                <button id="setGuitarBtn" class="guitar-btn">üé∏ Guitar</button>
            </div>

            <div id="instrument-desc" class="small">Listening to <strong>Piano (C Major)</strong></div>
            <br>
            <button id="goToLearnBtn">LISTEN & LEARN</button>
            <button id="backToMenuFromMelodyBtn" class="secondary">BACK TO MENU</button>
        </div>
    </div>

    <!-- Melody Learn Screen -->
    <div id="melody-learn-screen" class="ui-layer hidden">
        <div class="modal">
            <h1>Listen & Learn üëÇ</h1>
            <p>Tap a monster to hear its sound, or listen to them all!</p>
            <button id="listenAllBtn">üé∂ Play Scale</button>
            <div class="melody-grid learn-mode" id="learnGrid">
                <!-- Filled by JS -->
            </div>
            <button id="startQuizBtn" class="secondary">‚úÖ I'm Ready to Play!</button>
        </div>
    </div>

    <!-- Melody Round (Question) -->
    <div id="melody-round-screen" class="ui-layer hidden">
        <div class="modal">
            <h1>Which Monster Plays This Note?</h1>
            <p id="melodyRoundText">Round 1 / 5</p>
            <div class="melody-grid" id="quizGrid">
                <!-- Filled by JS -->
            </div>
            <button id="replayNoteBtn">üîä Hear Note Again</button>
        </div>
    </div>

    <!-- Melody Result -->
    <div id="melody-result-screen" class="ui-layer hidden">
        <div class="modal">
            <h1 id="melodyResultTitle">Nice Try!</h1>
            <p id="melodyResultMessage"></p>
            <div id="melodyResultDetails" class="small"></div>
            <button id="nextMelodyRoundBtn">NEXT ROUND</button>
            <button id="backToMelodyMenuBtn" class="secondary">BACK TO MELODY MENU</button>
        </div>
    </div>
</div>

<script>
/**
 * AUDIO SYSTEM & SCALES
 */
class AudioController {
    constructor() {
        this.ctx = null;
        this.currentInstrument = 'PIANO';
        
        // Define Scales
        this.scales = {
            PIANO: {
                names: ["C5","D5","E5","F5","G5","A5","B5","C6"],
                freqs: [523.25, 587.33, 659.25, 698.46, 783.99, 880.00, 987.77, 1046.50],
                wave: 'sine'
            },
            GUITAR: {
                names: ["E4","F#4","G#4","A4","B4","C#5","D#5","E5"],
                freqs: [329.63, 369.99, 415.30, 440.00, 493.88, 554.37, 622.25, 659.25],
                wave: 'triangle' // Triangle feels more like a plucked string
            }
        };
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    getScale() {
        return this.scales[this.currentInstrument];
    }

    setInstrument(name) {
        this.currentInstrument = name;
    }

    playJumpSound() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = this.getScale().wave;
        // Random note from the current scale
        const scaleFreqs = this.getScale().freqs;
        const base = scaleFreqs[Math.floor(Math.random() * 4)]; 
        osc.frequency.setValueAtTime(base, this.ctx.currentTime);
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.15, this.ctx.currentTime + 0.06);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
    }

    playLandHeight(heightRatio) {
        if (!this.ctx) return;
        const scale = this.getScale();
        const index = Math.min(scale.freqs.length - 1, Math.max(0, Math.floor(heightRatio * scale.freqs.length)));
        const freq = scale.freqs[index];
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = scale.wave;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 0.06);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.6);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.6);
        return scale.names[index];
    }

    playDing() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(880, this.ctx.currentTime);
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.18, this.ctx.currentTime + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.4);
    }

    playOops() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(220, this.ctx.currentTime + 0.25);
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.15, this.ctx.currentTime + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.35);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.35);
    }

    playNoteByName(noteName) {
        if (!this.ctx) return;
        const scale = this.getScale();
        const idx = scale.names.indexOf(noteName);
        if (idx === -1) return;
        const freq = scale.freqs[idx];
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = scale.wave;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.25, this.ctx.currentTime + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.7);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.7);
    }
}

const audio = new AudioController();

/**
 * MONSTER BEAT GAME ENGINE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let appMode = 'MENU'; 
let frames = 0;
let score = 0;
let highScore = parseInt(localStorage.getItem('monsterBeatHighScore') || '0', 10);
let highNoteReached = '‚Äî';
let gameSpeed = 5;
let width, height;

// UI Elements
const scoreDisplay = document.getElementById('scoreDisplay');
const modeHud = document.getElementById('modeHud');
const menuScreen = document.getElementById('menu-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const pauseScreen = document.getElementById('pause-screen');
const hud = document.getElementById('hud');
const finalScoreText = document.getElementById('finalScoreText');
const highScoreText = document.getElementById('highScoreText');
const highNoteText = document.getElementById('highNoteText');

// Melody screens
const melodyModeScreen = document.getElementById('melody-mode-screen');
const melodyLearnScreen = document.getElementById('melody-learn-screen');
const melodyRoundScreen = document.getElementById('melody-round-screen');
const melodyResultScreen = document.getElementById('melody-result-screen');
const learnGrid = document.getElementById('learnGrid');
const quizGrid = document.getElementById('quizGrid');
const instrumentDesc = document.getElementById('instrument-desc');

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
}
window.addEventListener('resize', resize);
resize();

// Input
function handleInputStart(e) {
    if (e.type === 'keydown' && e.code !== 'Space' && e.code !== 'Escape') return;
    if (e.type === 'keydown' && e.code === 'Escape') {
        if (appMode === 'BEAT') togglePause();
        return;
    }
    if (appMode === 'BEAT') player.jump();
}

window.addEventListener('keydown', handleInputStart);
window.addEventListener('touchstart', (e) => {
    if (appMode === 'BEAT') player.jump();
}, {passive: false});
window.addEventListener('mousedown', () => {
    if (appMode === 'BEAT') player.jump();
});

// Game Objects
const player = {
    x: 100, y: 0, width: 40, height: 40,
    dy: 0, jumpPower: -11, gravity: 0.55,
    grounded: false, color: '#FF9FF3', rotation: 0,
    reset() {
        this.y = height / 2; this.dy = 0; this.rotation = 0; this.grounded = false;
    },
    update() {
        this.dy += this.gravity; this.y += this.dy;
        if (!this.grounded) this.rotation += 0.13;
        else this.rotation = Math.round(this.rotation / (Math.PI / 2)) * (Math.PI / 2);
        if (this.y > height + this.height) endBeatGame();
    },
    jump() {
        if (this.grounded) {
            this.dy = this.jumpPower; this.grounded = false;
            audio.playJumpSound();
            createParticles(this.x + this.width/2, this.y + this.height, 8, '#FF9FF3');
        }
    },
    draw() {
        ctx.save();
        ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
        ctx.rotate(this.rotation);
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.roundRect(-this.width / 2, -this.height / 2, this.width, this.height, 8);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'white';
        ctx.beginPath(); ctx.arc(-6, -5, 7, 0, Math.PI*2); ctx.arc(10, -5, 7, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#2c3e50';
        ctx.beginPath(); ctx.arc(-4, -4, 3, 0, Math.PI*2); ctx.arc(12, -4, 3, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(2, 4, 5, 0, Math.PI); ctx.stroke();
        ctx.restore();
    }
};

let platforms = []; let particles = []; let stars = []; let lastLandNote = '‚Äî';

class Platform {
    constructor(x, y, w) {
        this.x = x; this.y = y; this.width = w; this.height = 16;
        this.hue = Math.random() * 360; this.playedLand = false;
    }
    update() { this.x -= gameSpeed; }
    draw() {
        ctx.fillStyle = `hsl(${this.hue}, 80%, 60%)`;
        ctx.shadowBlur = 12; ctx.shadowColor = `hsl(${this.hue}, 80%, 60%)`;
        ctx.beginPath(); ctx.roundRect(this.x, this.y, this.width, this.height, 6); ctx.fill();
        ctx.fillStyle = `hsl(${this.hue}, 80%, 85%)`; ctx.shadowBlur = 0;
        ctx.fillRect(this.x, this.y, this.width, 4);
    }
}

class Star {
    constructor(x, y) {
        this.x = x; this.y = y; this.size = 14; this.collected = false; this.angle = 0;
    }
    update() { this.x -= gameSpeed; this.angle += 0.08; }
    draw() {
        if (this.collected) return;
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        ctx.fillStyle = '#FECA57'; ctx.shadowBlur = 10; ctx.shadowColor = '#FECA57';
        ctx.beginPath(); ctx.moveTo(0, -this.size/2); ctx.lineTo(this.size/2, 0);
        ctx.lineTo(0, this.size/2); ctx.lineTo(-this.size/2, 0); ctx.closePath(); ctx.fill();
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.size = Math.random() * 5 + 2;
        this.speedX = Math.random() * 5 - 2.5; this.speedY = Math.random() * 5 - 2.5;
        this.color = color; this.life = 1.0;
    }
    update() {
        this.x += this.speedX; this.y += this.speedY; this.life -= 0.025;
    }
    draw() {
        ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

function createParticles(x, y, count, color) {
    for (let i = 0; i < count; i++) particles.push(new Particle(x, y, color));
}

function generateBeatLevel() {
    if (platforms.length > 0 && platforms[0].x + platforms[0].width < -100) platforms.shift();
    if (stars.length > 0 && stars[0].x < -50) stars.shift();

    let lastPlatform = platforms[platforms.length - 1];
    if (!lastPlatform || lastPlatform.x + lastPlatform.width < width) {
        let gap = 90 + Math.random() * 130; if (gap > 200) gap = 200;
        let w = 220 + Math.random() * 260;
        let y = lastPlatform ? lastPlatform.y + (Math.random() * 180 - 90) : height / 2 + 60;
        if (y < 140) y = 140; if (y > height - 90) y = height - 90;
        let x = lastPlatform ? lastPlatform.x + lastPlatform.width + gap : width;
        let p = new Platform(x, y, w);
        platforms.push(p);
        if (Math.random() > 0.72) stars.push(new Star(x + w / 2, y - 70 - Math.random() * 40));
    }
}

function checkCollisions() {
    player.grounded = false;
    for (let p of platforms) {
        if (player.dy > 0 && player.x + player.width > p.x && player.x < p.x + p.width &&
            player.y + player.height >= p.y && player.y + player.height <= p.y + p.height + 10) {
            player.grounded = true; player.dy = 0; player.y = p.y - player.height;
            if (!p.playedLand) {
                p.playedLand = true;
                let heightRatio = 1 - (p.y / height);
                let noteName = audio.playLandHeight(heightRatio);
                lastLandNote = noteName || '‚Äî';
                createParticles(player.x + player.width/2, player.y + player.height, 5, p.hue);
            }
        }
    }
    for (let s of stars) {
        if (!s.collected && player.x < s.x + s.size && player.x + player.width > s.x - s.size &&
            player.y < s.y + s.size && player.y + player.height > s.y - s.size) {
            s.collected = true; score += 50; scoreDisplay.innerText = score;
            createParticles(s.x, s.y, 12, '#FECA57'); audio.playDing();
        }
    }
}

function drawBackground() {
    let gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, '#16213e'); gradient.addColorStop(1, '#0f3460');
    ctx.fillStyle = gradient; ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    for(let i=0; i<50; i++) {
        let x = (Math.sin(i * 132.1) * width + frames * (i % 3 === 0 ? 0.4 : 0.15)) % width;
        let y = (Math.cos(i * 432.1) * height + height) % height;
        if (x < 0) x += width;
        let size = (i % 5) + 1;
        let twinkle = (Math.sin(frames * 0.04 + i) + 1) / 2;
        ctx.globalAlpha = twinkle;
        ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1.0;
}

function beatLoop() {
    if (appMode !== 'BEAT') return;
    frames++;
    if (frames % 720 === 0) gameSpeed += 0.4;
    ctx.clearRect(0, 0, width, height);
    drawBackground();
    generateBeatLevel();
    platforms.forEach(p => { p.update(); p.draw(); });
    stars.forEach(s => { s.update(); s.draw(); });
    player.update(); checkCollisions(); player.draw();
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update(); particles[i].draw();
        if (particles[i].life <= 0) particles.splice(i, 1);
    }
    if (frames % 10 === 0) { score++; scoreDisplay.innerText = score; }
    requestAnimationFrame(beatLoop);
}

function startBeatGame() {
    audio.init(); appMode = 'BEAT'; score = 0; frames = 0; gameSpeed = 5; lastLandNote = '‚Äî';
    platforms = []; stars = []; particles = []; scoreDisplay.innerText = '0';
    platforms.push(new Platform(50, height/2 + 60, 480));
    player.reset(); player.grounded = true;
    menuScreen.classList.add('hidden'); gameOverScreen.classList.add('hidden');
    hud.classList.remove('hidden'); modeHud.innerText = 'Monster Beat';
    beatLoop();
}

function endBeatGame() {
    appMode = 'GAMEOVER';
    if (score > highScore) { highScore = score; localStorage.setItem('monsterBeatHighScore', highScore); }
    finalScoreText.innerText = `Score: ${score}`;
    highScoreText.innerText = `Best: ${highScore}`;
    highNoteText.innerText = `Highest Note Reached: ${lastLandNote}`;
    hud.classList.add('hidden'); gameOverScreen.classList.remove('hidden');
}

function togglePause() {
    if (appMode === 'BEAT') { appMode = 'PAUSE'; pauseScreen.classList.remove('hidden'); }
    else if (appMode === 'PAUSE') { appMode = 'BEAT'; pauseScreen.classList.add('hidden'); beatLoop(); }
}

/**
 * MELODY MONSTERS LOGIC
 */

// Base Monster Data (visuals stay same)
const baseMonsters = [
    { name: "Cat",   emoji: "üê±", color: "#FF9FF3" },
    { name: "Dog",   emoji: "üê∂", color: "#FECA57" },
    { name: "Bird",  emoji: "üê¶", color: "#1DD1A1" },
    { name: "Frog",  emoji: "üê∏", color: "#48DBFB" },
    { name: "Lion",  emoji: "ü¶Å", color: "#5F27CD" },
    { name: "Elephant", emoji: "üêò", color: "#FF6B6B" },
    { name: "Monkey",emoji: "üêµ", color: "#C8D6E5" },
    { name: "Pig",   emoji: "üê∑", color: "#FF9FF3" }
];

// Dynamic monsters (changes based on scale)
let melodyMonsters = [];
let melodyRound = 1; 
let melodyTotalRounds = 5; 
let melodyTargetNote = null; 
let melodyStreak = 0;

function updateMelodyMonsters() {
    const scale = audio.getScale();
    melodyMonsters = baseMonsters.map((m, idx) => {
        return {
            ...m,
            note: scale.names[idx],
            freq: scale.freqs[idx]
        };
    });
}

function showMelodyModeScreen() {
    appMode = 'MELODY_INTRO';
    updateMelodyMonsters(); // Ensure monsters match current audio setting
    menuScreen.classList.add('hidden'); hud.classList.add('hidden'); gameOverScreen.classList.add('hidden');
    melodyModeScreen.classList.remove('hidden'); melodyLearnScreen.classList.add('hidden');
    melodyRoundScreen.classList.add('hidden'); melodyResultScreen.classList.add('hidden');
}

function setInstrument(instrument) {
    audio.setInstrument(instrument);
    updateMelodyMonsters();
    
    // UI Updates
    const pianoBtn = document.getElementById('setPianoBtn');
    const guitarBtn = document.getElementById('setGuitarBtn');
    
    if (instrument === 'PIANO') {
        pianoBtn.style.opacity = "1";
        pianoBtn.style.border = "2px solid white";
        guitarBtn.style.opacity = "0.5";
        guitarBtn.style.border = "none";
        instrumentDesc.innerHTML = `Listening to <strong>Piano (C Major)</strong>`;
    } else {
        guitarBtn.style.opacity = "1";
        guitarBtn.style.border = "2px solid white";
        pianoBtn.style.opacity = "0.5";
        pianoBtn.style.border = "none";
        instrumentDesc.innerHTML = `Listening to <strong>Guitar (E Major)</strong>`;
    }
}

function showLearnScreen() {
    appMode = 'MELODY_LEARN';
    melodyModeScreen.classList.add('hidden');
    melodyLearnScreen.classList.remove('hidden');
    renderLearnGrid();
}

function renderLearnGrid() {
    learnGrid.innerHTML = '';
    melodyMonsters.forEach((m, idx) => {
        const card = document.createElement('div');
        card.className = 'melody-card';
        card.id = `learn-card-${idx}`;
        card.innerHTML = `<span class="emoji">${m.emoji}</span><span class="note-name">${m.note}</span>`;
        card.addEventListener('click', () => {
            if (appMode === 'MELODY_LEARN') {
                audio.playNoteByName(m.note);
                highlightCard(card);
            }
        });
        learnGrid.appendChild(card);
    });
}

function highlightCard(card) {
    card.classList.add('active-sequence');
    setTimeout(() => card.classList.remove('active-sequence'), 400);
}

async function playAllNotes() {
    if (appMode !== 'MELODY_LEARN') return;
    const btn = document.getElementById('listenAllBtn');
    btn.disabled = true;
    btn.innerText = "Playing...";

    for (let i = 0; i < melodyMonsters.length; i++) {
        const m = melodyMonsters[i];
        const card = document.getElementById(`learn-card-${i}`);
        
        // Visual
        card.classList.add('active-sequence');
        // Audio
        audio.playNoteByName(m.note);
        
        // Wait
        await new Promise(r => setTimeout(r, 700));
        
        card.classList.remove('active-sequence');
    }

    btn.disabled = false;
    btn.innerText = "üé∂ Play Scale";
}

function startMelodyMiniGame() {
    audio.init();
    melodyRound = 1; melodyStreak = 0;
    startMelodyRound();
}

function startMelodyRound() {
    appMode = 'MELODY_ROUND';
    melodyLearnScreen.classList.add('hidden'); melodyResultScreen.classList.add('hidden');
    melodyRoundScreen.classList.remove('hidden');

    document.getElementById('melodyRoundText').innerText = `Round ${melodyRound} / ${melodyTotalRounds}`;

    // Pick target
    melodyTargetNote = melodyMonsters[Math.floor(Math.random() * melodyMonsters.length)];
    renderQuizGrid(false);

    // Delay then play
    setTimeout(() => {
        if (appMode === 'MELODY_ROUND') audio.playNoteByName(melodyTargetNote.note);
    }, 600);
}

function renderQuizGrid(showResult, correctMonster, wrongMonster) {
    quizGrid.innerHTML = '';
    melodyMonsters.forEach(m => {
        const card = document.createElement('div');
        card.className = 'melody-card';
        if (showResult) {
            if (m === correctMonster) {
                card.style.background = 'rgba(29, 209, 161, 0.45)';
                card.style.border = '2px solid #1DD1A1';
            } else if (m === wrongMonster) {
                card.style.background = 'rgba(255, 107, 107, 0.4)';
                card.style.border = '2px solid #FF6B6B';
            }
        }
        card.innerHTML = `<span class="emoji">${m.emoji}</span><span class="note-name">${m.note}</span>`;
        card.addEventListener('click', () => {
            if (appMode === 'MELODY_ROUND' && !showResult) handleMelodyGuess(m);
            else audio.playNoteByName(m.note);
        });
        quizGrid.appendChild(card);
    });
}

function handleMelodyGuess(monster) {
    if (monster.note === melodyTargetNote.note) {
        melodyStreak++;
        audio.playDing();
        showMelodyResult(true, monster, null);
    } else {
        audio.playOops();
        showMelodyResult(false, melodyTargetNote, monster);
    }
}

function showMelodyResult(correct, correctMonster, wrongMonster) {
    appMode = 'MELODY_RESULT';
    melodyRoundScreen.classList.add('hidden'); melodyResultScreen.classList.remove('hidden');
    const title = document.getElementById('melodyResultTitle');
    const message = document.getElementById('melodyResultMessage');
    const details = document.getElementById('melodyResultDetails');

    if (correct) {
        title.innerText = "Correct! üéâ";
        message.innerText = `You found the ${correctMonster.note} monster!`;
        details.innerText = `${correctMonster.name} plays ${correctMonster.note}. Great ear!`;
    } else {
        title.innerText = "Oops!";
        message.innerText = `That was ${wrongMonster.note}, not ${melodyTargetNote.note}.`;
        details.innerText = `${correctMonster.name} plays ${correctMonster.note}. Listen again next round!`;
    }
    renderQuizGrid(true, correctMonster, wrongMonster);
}

function nextMelodyRound() {
    if (melodyRound >= melodyTotalRounds) backToMelodyMenu();
    else { melodyRound++; startMelodyRound(); }
}

function backToMelodyMenu() {
    appMode = 'MELODY_INTRO';
    melodyResultScreen.classList.add('hidden'); melodyRoundScreen.classList.add('hidden');
    melodyModeScreen.classList.remove('hidden');
}

function backToMainMenu() {
    appMode = 'MENU';
    menuScreen.classList.remove('hidden'); hud.classList.add('hidden');
    gameOverScreen.classList.add('hidden'); pauseScreen.classList.add('hidden');
    melodyModeScreen.classList.add('hidden'); melodyLearnScreen.classList.add('hidden');
    melodyRoundScreen.classList.add('hidden'); melodyResultScreen.classList.add('hidden');
}

/**
 * BUTTON HOOKUPS
 */
document.getElementById('playBeatBtn').addEventListener('click', startBeatGame);
document.getElementById('playMelodyBtn').addEventListener('click', showMelodyModeScreen);
document.getElementById('restartBtn').addEventListener('click', startBeatGame);
document.getElementById('backToMenuBtn').addEventListener('click', backToMainMenu);

document.getElementById('resumeBtn').addEventListener('click', togglePause);
document.getElementById('quitBtn').addEventListener('click', () => {
    appMode = 'MENU'; pauseScreen.classList.add('hidden'); hud.classList.add('hidden'); menuScreen.classList.remove('hidden');
});

document.getElementById('setPianoBtn').addEventListener('click', () => setInstrument('PIANO'));
document.getElementById('setGuitarBtn').addEventListener('click', () => setInstrument('GUITAR'));

document.getElementById('goToLearnBtn').addEventListener('click', showLearnScreen);
document.getElementById('listenAllBtn').addEventListener('click', playAllNotes);
document.getElementById('startQuizBtn').addEventListener('click', startMelodyMiniGame);
document.getElementById('backToMenuFromMelodyBtn').addEventListener('click', backToMainMenu);
document.getElementById('nextMelodyRoundBtn').addEventListener('click', nextMelodyRound);
document.getElementById('backToMelodyMenuBtn').addEventListener('click', backToMelodyMenu);
document.getElementById('replayNoteBtn').addEventListener('click', () => {
    if (appMode === 'MELODY_ROUND' && melodyTargetNote) audio.playNoteByName(melodyTargetNote.note);
});

</script>
</body>
</html>
